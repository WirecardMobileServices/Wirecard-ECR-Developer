{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wirecard Products for Payment Acceptance Wirecard offers wide range of products that can be used for integrating the payment acceptance on mobile or desktop platforms. ECR SDK to integrate the standalone POS device into your current payment solution ePOS iOS Mobile Checkout and Android Mobile Checkout to use ready-made brandable mobile payment solution ePOS SDK to integrate into your mobile payment solution","title":"Welcome"},{"location":"#wirecard-products-for-payment-acceptance","text":"Wirecard offers wide range of products that can be used for integrating the payment acceptance on mobile or desktop platforms. ECR SDK to integrate the standalone POS device into your current payment solution ePOS iOS Mobile Checkout and Android Mobile Checkout to use ready-made brandable mobile payment solution ePOS SDK to integrate into your mobile payment solution","title":"Wirecard Products for Payment Acceptance"},{"location":"ecr-overview/","text":"ECR Overview Electronic Cash Register (ECR) Integration is to allow front-line users such as cashiers to input/trigger supported transactions at single point, and at the same time, relevant information needs to be passed to a Payment Device which sends the information securely to a payment host for authentication and approval. As such, there is a need for an interface to send data between ECR and Payment Device.","title":"Overview"},{"location":"ecr-overview/#ecr-overview","text":"Electronic Cash Register (ECR) Integration is to allow front-line users such as cashiers to input/trigger supported transactions at single point, and at the same time, relevant information needs to be passed to a Payment Device which sends the information securely to a payment host for authentication and approval. As such, there is a need for an interface to send data between ECR and Payment Device.","title":"ECR Overview"},{"location":"int-initialization/","text":"Initialization Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) //TcpIpDevice - Type of the Communication protocol to be used for POS devices //JsonWrapper - Type of Messages used for the POS communication","title":"Initialization"},{"location":"int-initialization/#initialization","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) //TcpIpDevice - Type of the Communication protocol to be used for POS devices //JsonWrapper - Type of Messages used for the POS communication","title":"Initialization"},{"location":"int-setup-android-gradle/","text":"Set up with Gradle Hassle-free setup on Android is now available using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build. Caution The minimum API level supported by this library is API 15 (4.0.3). Release notes Release notes are available here: EcrSDK Release notes Gradle dependencies Add the following lines to your root build.gradle file to include the SDK in your Android Studio project: Info Latest version: //build.gradle (Project: ...) allprojects { repositories { maven { url \"https://jitpack.io\" } maven { url \"https://dl.bintray.com/wirecardmobileservices/Wirecard-ECR\" } } } //build.gradle (Module: ...) dependencies { def ecrVersion = \"{{latestVersion}}\" implementation \"de.wirecard.ecr:EcrSdk:$ecrVersion\" } Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Android"},{"location":"int-setup-android-gradle/#set-up-with-gradle","text":"Hassle-free setup on Android is now available using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build. Caution The minimum API level supported by this library is API 15 (4.0.3).","title":"Set up with Gradle"},{"location":"int-setup-android-gradle/#release-notes","text":"Release notes are available here: EcrSDK Release notes","title":"Release notes"},{"location":"int-setup-android-gradle/#gradle-dependencies","text":"Add the following lines to your root build.gradle file to include the SDK in your Android Studio project: Info Latest version: //build.gradle (Project: ...) allprojects { repositories { maven { url \"https://jitpack.io\" } maven { url \"https://dl.bintray.com/wirecardmobileservices/Wirecard-ECR\" } } } //build.gradle (Module: ...) dependencies { def ecrVersion = \"{{latestVersion}}\" implementation \"de.wirecard.ecr:EcrSdk:$ecrVersion\" } Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Gradle dependencies"},{"location":"int-setup-android-manual/","text":"Set up Manually Caution Set up Manually is not recommended way, but it's still available. Definitely see Set up with Gradle section. The minimum API level supported by this library is API 15 (4.0.3). Follow the steps listed below to set up the Wirecard ECR SDK for Android manually: Open JFrog Bintray repository website, where you can find ECR SDK library. For library, in Files section, and appropriate version folder, locate an .aar files. Manually download those .aar files to the libs folder in your project. Make sure, you have flatDir { dirs 'libs' } in your project build.gradle file. Add a dependency in the module build.gradle file e.g. compile(name: 'EcrSdk-version', ext: 'aar') . Tip After set up of ECR SDK, you can continue with SDK Initialization section.","title":"Set up Manually"},{"location":"int-setup-android-manual/#set-up-manually","text":"Caution Set up Manually is not recommended way, but it's still available. Definitely see Set up with Gradle section. The minimum API level supported by this library is API 15 (4.0.3). Follow the steps listed below to set up the Wirecard ECR SDK for Android manually: Open JFrog Bintray repository website, where you can find ECR SDK library. For library, in Files section, and appropriate version folder, locate an .aar files. Manually download those .aar files to the libs folder in your project. Make sure, you have flatDir { dirs 'libs' } in your project build.gradle file. Add a dependency in the module build.gradle file e.g. compile(name: 'EcrSdk-version', ext: 'aar') . Tip After set up of ECR SDK, you can continue with SDK Initialization section.","title":"Set up Manually"},{"location":"int-setup-ios/","text":"Set up using XCFramework This library requires at least iOS 13 or OSX 10.15 The ECR SDK is distributed as precompiled framework using the XCFramework. Checkout the latest release of Wirecard ECR iOS and drag&drop XCFrameworks into your project. WDEcr.xcframework WDSocket.xcframework Tip After set up of ECR SDK, you can continue with SDK Initialization section.","title":"iOS"},{"location":"int-setup-ios/#set-up-using-xcframework","text":"This library requires at least iOS 13 or OSX 10.15 The ECR SDK is distributed as precompiled framework using the XCFramework. Checkout the latest release of Wirecard ECR iOS and drag&drop XCFrameworks into your project. WDEcr.xcframework WDSocket.xcframework Tip After set up of ECR SDK, you can continue with SDK Initialization section.","title":"Set up using XCFramework"},{"location":"msg-echo/","text":"Echo The Echo Test command is used to confirm that the communication between ECR and Payment Device is working properly. Java import de.wirecard.ecr.EcrSdk EcrSdk ecr ; String ecrIp = \"127.0.0.1\" ; // IP address of ecr device int ecrPort = 7890 ; // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ); ecr . echo ( EchoRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( response -> ..., throwable -> ...); Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . echo ( EchoRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . echo () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Echo Test"},{"location":"msg-echo/#echo","text":"The Echo Test command is used to confirm that the communication between ECR and Payment Device is working properly. Java import de.wirecard.ecr.EcrSdk EcrSdk ecr ; String ecrIp = \"127.0.0.1\" ; // IP address of ecr device int ecrPort = 7890 ; // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ); ecr . echo ( EchoRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( response -> ..., throwable -> ...); Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . echo ( EchoRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . echo () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Echo"},{"location":"msg-last-settlement/","text":"Sale Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . getLastSettlement ( GetLastSettlementRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . getLastSettlement () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Last Settlement"},{"location":"msg-last-settlement/#sale","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . getLastSettlement ( GetLastSettlementRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . getLastSettlement () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-last-transaction/","text":"Sale Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . getLastTransaction ( GetLastTransactionRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . getLastTransaction () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Last Transaction"},{"location":"msg-last-transaction/#sale","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . getLastTransaction ( GetLastTransactionRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . getLastTransaction () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-pairing/","text":"Pairing The Pairing command is for ECR to register a Device ID with the Payment Device. Future commands from ECR must contain this Device ID for the Payment Device to process the command. All other commands will be ignored. The transaction flow is as below: ECR sends Pairing command with Device to Payment Device Payment Device to store the Device ID. Payment Device return successful status with no data to ECR. The Pairing command will have to be sent with a different Device ID to change the existing Device ID stored in Payment Device, and to allow the Payment Device to process commands from the new Device. Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . pairing ( PairingRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . pairing ( EcrModel . Pairing . RequestBody ( deviceId : \"deviceId\" ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Pairing"},{"location":"msg-pairing/#pairing","text":"The Pairing command is for ECR to register a Device ID with the Payment Device. Future commands from ECR must contain this Device ID for the Payment Device to process the command. All other commands will be ignored. The transaction flow is as below: ECR sends Pairing command with Device to Payment Device Payment Device to store the Device ID. Payment Device return successful status with no data to ECR. The Pairing command will have to be sent with a different Device ID to change the existing Device ID stored in Payment Device, and to allow the Payment Device to process commands from the new Device. Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . pairing ( PairingRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . pairing ( EcrModel . Pairing . RequestBody ( deviceId : \"deviceId\" ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Pairing"},{"location":"msg-pre-auth/","text":"Sale Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . preAuth ( PreAuthRequest . PreAuthRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . preAuth ( EcrModel . PreAuth . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"PreAuthorization"},{"location":"msg-pre-auth/#sale","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . preAuth ( PreAuthRequest . PreAuthRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . preAuth ( EcrModel . PreAuth . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-refund/","text":"Sale Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . refund ( RefundRequest . RefundRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . refund ( EcrModel . Refund . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Refund"},{"location":"msg-refund/#sale","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . refund ( RefundRequest . RefundRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . refund ( EcrModel . Refund . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-sale/","text":"Sale Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . sale ( SaleRequest . SaleRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . NOT_SPECIFIC_EDC_TO_DECIDE , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . sale ( EcrModel . Sale . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-sale/#sale","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . sale ( SaleRequest . SaleRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . NOT_SPECIFIC_EDC_TO_DECIDE , orderId = \"orderId\" , deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . sale ( EcrModel . Sale . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Sale"},{"location":"msg-settlement/","text":"Settlement Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . settlement ( SettlementRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . settlement () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Settlement"},{"location":"msg-settlement/#settlement","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . settlement ( SettlementRequestData ( deviceId = \"deviceId\" )) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . settlement () . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Settlement"},{"location":"msg-void/","text":"Void Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . void ( VoidRequest . VoidRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , invoiceNumber = \"invoiceNumber\" , orderId = \"orderId\" , deviceId = \"deviceId\" ) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . void ( EcrModel . Void . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard , invoiceNumber : \"123456\" ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Void"},{"location":"msg-void/#void","text":"Kotlin import de.wirecard.ecr.EcrSdk var ecr : EcrSdk var ecrIp : String = \"127.0.0.1\" // IP address of ecr device var ecrPort : Int = 7890 // device port ecr = EcrSdkFactory . createTcpIp ( ecrIp , ecrPort ) ecr . void ( VoidRequest . VoidRequestData ( transactionAmount = \"2.0\" , paymentType = PaymentType . CASH , invoiceNumber = \"invoiceNumber\" , orderId = \"orderId\" , deviceId = \"deviceId\" ) . subscribeOn ( Schedulers . io ()) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe { response , throwable -> ... } Swift import Ecr let device = TcpIpDevice ( ip : \"172.20.10.105\" , port : 7890 ) let ecr = Ecr < TcpIpDevice , JsonWrapper >( device : device ) var cancellables = Set < AnyCancellable >() ecr . void ( EcrModel . Void . RequestBody ( transactionAmount : \"10\" , paymentType : . cardCreditChargeCard , invoiceNumber : \"123456\" ) ) . sink ( receiveCompletion : { completion in switch completion { case . finished : break ; case . failure ( let error ): print ( \"error: \\( error ) \" ) } }, receiveValue : { data in print ( \"data: \\( data ) \" ) }) . store ( in : & cancellables )","title":"Void"},{"location":"transaction-flow/","text":"Transaction Flow The general flow for an ECR integrated transaction can be seen in the following sections: Sales/IPP Sale/Refund/Void/Pre-Auth/Sale Comp/Pre-Auth Supplement/Void Pre-Auth Settlement","title":"Transaction Flow"},{"location":"transaction-flow/#transaction-flow","text":"The general flow for an ECR integrated transaction can be seen in the following sections:","title":"Transaction Flow"},{"location":"transaction-flow/#salesipp-salerefundvoidpre-authsale-comppre-auth-supplementvoid-pre-auth","text":"","title":"Sales/IPP Sale/Refund/Void/Pre-Auth/Sale Comp/Pre-Auth Supplement/Void Pre-Auth"},{"location":"transaction-flow/#settlement","text":"","title":"Settlement"}]}